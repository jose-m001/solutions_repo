{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 1. Theoretical Foundation Projectile Motion Analysis 1.1 Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. 1.2 Deliverables 1 . A Python script implementing the simulation of projectile motion. 2 . Detailed description of the family of solutions derived from the governing equations 3 . Graphs illustrating the trajectory and range as a function of the angle of projection. 4 . A discussion of the limitations and potential extensions of the idealized model, such as incorporating air resistance or uneven terrain. 1.3 Theoretical Foundation Governing Equations The motion of a projectile can be described using the following kinematic equations: 1 . Horizontal Motion: $$ x(t) = v_0 \\cos(\\theta) t $$ 2 . Vertical Motion: $$ y(t) = h + v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ Where: - \\(x(t)\\) and \\(y(t)\\) are the horizontal and vertical positions at time \\(t\\) , respectively. - \\((v_0)\\) is the initial velocity. - \\((\\theta)\\) is the angle of projection. - \\((h)\\) is the initial height. - \\((g)\\) is the acceleration due to gravity. Range Derivation The horizontal range \\(R\\) is the distance traveled by the projectile when it returns to the same vertical height as the launch point ( \\(y = 0\\) ). For a projectile launched from ground level ( \\(h = 0\\) ): 1 . Solve for the time of flight \\(T\\) : $$ T = \\frac{2 v_0 \\sin(\\theta)}{g} $$ 2 . Calculate the range: $$ R = v_0 \\cos(\\theta) T $$ $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation shows that the range depends on the square of the initial velocity, the sine of twice the angle, and inversely on gravity. 2. Analysis of the Range Dependency on Angle The range is maximized when \\(\\sin(2\\theta)\\) is maximized, which occurs at \\(\\theta = 45^\\circ\\) . Effect of Other Parameters - Initial Velocity: The range increases quadratically with \\(v_0\\) . - Gravitational Acceleration: The range decreases as \\(g\\) increases. - Launch Height: For \\(h > 0\\) , the time of flight is longer, increasing the range. 3. Practical Applications Real-World Scenarios - Uneven Terrain: The landing point depends on the elevation difference. - Air Resistance: Introduces drag force, reducing the range and altering the trajectory. - Sports: Understanding ball trajectories in soccer, basketball, etc. 4. Implementation Python Simulation Below is a Python script to simulate and visualize projectile motion: import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, theta, h, g=9.81): theta_rad = np.radians(theta) # Time of flight (quadratic formula for y=0) t_flight = (v0 * np.sin(theta_rad) + np.sqrt((v0 * np.sin(theta_rad))**2 + 2 * g * h)) / g # Time array t = np.linspace(0, t_flight, num=500) # Trajectory equations x = v0 * np.cos(theta_rad) * t y = h + v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 return x, y def plot_range_vs_angle(v0, h, g=9.81): angles = np.linspace(0, 90, num=500) ranges = [] for theta in angles: theta_rad = np.radians(theta) term = (v0 * np.sin(theta_rad))**2 + 2 * g * h t_flight = (v0 * np.sin(theta_rad) + np.sqrt(term)) / g R = v0 * np.cos(theta_rad) * t_flight ranges.append(R) plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f\"Initial Height: {h} m\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Range vs Angle of Projection\") plt.legend() plt.grid() plt.show() # Example usage v0 = 20 # Initial velocity in m/s h = 0 # Launch height in meters g = 9.81 # Gravitational acceleration # Simulate trajectory x, y = projectile_motion(v0, 45, h, g) # Plot trajectory plt.figure(figsize=(10, 6)) plt.plot(x, y, label=\"Trajectory (45 degrees)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(\"Projectile Motion Trajectory\") plt.legend() plt.grid() plt.show() # Plot range vs angle plot_range_vs_angle(v0, h, g) 5. Discussion Limitations - No Air Resistance: Assumes a vacuum, leading to an overestimation of range. - Constant Gravity: Neglects variations in gravitational acceleration with altitude. - Point Mass: Ignores rotational effects or aerodynamic properties. Extensions - Incorporate drag forces to model air resistance. - Simulate projectile motion on non-level surfaces. - Explore the effect of wind and spin on the projectile.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis","text":"","title":"Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"1.1 Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-deliverables","text":"1 . A Python script implementing the simulation of projectile motion. 2 . Detailed description of the family of solutions derived from the governing equations 3 . Graphs illustrating the trajectory and range as a function of the angle of projection. 4 . A discussion of the limitations and potential extensions of the idealized model, such as incorporating air resistance or uneven terrain.","title":"1.2 Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-theoretical-foundation","text":"","title":"1.3 Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations","text":"The motion of a projectile can be described using the following kinematic equations: 1 . Horizontal Motion: $$ x(t) = v_0 \\cos(\\theta) t $$ 2 . Vertical Motion: $$ y(t) = h + v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ Where: - \\(x(t)\\) and \\(y(t)\\) are the horizontal and vertical positions at time \\(t\\) , respectively. - \\((v_0)\\) is the initial velocity. - \\((\\theta)\\) is the angle of projection. - \\((h)\\) is the initial height. - \\((g)\\) is the acceleration due to gravity.","title":"Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-derivation","text":"The horizontal range \\(R\\) is the distance traveled by the projectile when it returns to the same vertical height as the launch point ( \\(y = 0\\) ). For a projectile launched from ground level ( \\(h = 0\\) ): 1 . Solve for the time of flight \\(T\\) : $$ T = \\frac{2 v_0 \\sin(\\theta)}{g} $$ 2 . Calculate the range: $$ R = v_0 \\cos(\\theta) T $$ $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation shows that the range depends on the square of the initial velocity, the sine of twice the angle, and inversely on gravity.","title":"Range Derivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dependency-on-angle","text":"The range is maximized when \\(\\sin(2\\theta)\\) is maximized, which occurs at \\(\\theta = 45^\\circ\\) .","title":"Dependency on Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-other-parameters","text":"- Initial Velocity: The range increases quadratically with \\(v_0\\) . - Gravitational Acceleration: The range decreases as \\(g\\) increases. - Launch Height: For \\(h > 0\\) , the time of flight is longer, increasing the range.","title":"Effect of Other Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-scenarios","text":"- Uneven Terrain: The landing point depends on the elevation difference. - Air Resistance: Introduces drag force, reducing the range and altering the trajectory. - Sports: Understanding ball trajectories in soccer, basketball, etc.","title":"Real-World Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation","text":"Below is a Python script to simulate and visualize projectile motion: import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, theta, h, g=9.81): theta_rad = np.radians(theta) # Time of flight (quadratic formula for y=0) t_flight = (v0 * np.sin(theta_rad) + np.sqrt((v0 * np.sin(theta_rad))**2 + 2 * g * h)) / g # Time array t = np.linspace(0, t_flight, num=500) # Trajectory equations x = v0 * np.cos(theta_rad) * t y = h + v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 return x, y def plot_range_vs_angle(v0, h, g=9.81): angles = np.linspace(0, 90, num=500) ranges = [] for theta in angles: theta_rad = np.radians(theta) term = (v0 * np.sin(theta_rad))**2 + 2 * g * h t_flight = (v0 * np.sin(theta_rad) + np.sqrt(term)) / g R = v0 * np.cos(theta_rad) * t_flight ranges.append(R) plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f\"Initial Height: {h} m\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Range vs Angle of Projection\") plt.legend() plt.grid() plt.show() # Example usage v0 = 20 # Initial velocity in m/s h = 0 # Launch height in meters g = 9.81 # Gravitational acceleration # Simulate trajectory x, y = projectile_motion(v0, 45, h, g) # Plot trajectory plt.figure(figsize=(10, 6)) plt.plot(x, y, label=\"Trajectory (45 degrees)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(\"Projectile Motion Trajectory\") plt.legend() plt.grid() plt.show() # Plot range vs angle plot_range_vs_angle(v0, h, g)","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-discussion","text":"","title":"5. Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"- No Air Resistance: Assumes a vacuum, leading to an overestimation of range. - Constant Gravity: Neglects variations in gravitational acceleration with altitude. - Point Mass: Ignores rotational effects or aerodynamic properties.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#extensions","text":"- Incorporate drag forces to model air resistance. - Simulate projectile motion on non-level surfaces. - Explore the effect of wind and spin on the projectile.","title":"Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 1. Theoretical Foundation Investigating the Dynamics of a Forced Damped Pendulum 1.1 Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena serve as a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. By systematically varying these parameters, a diverse class of solutions can be observed, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications such as energy harvesting, vibration isolation, and mechanical resonance. 1.2 Deliverables 1 . A Python script implementing the simulation of a forced damped pendulum. 2 . Graphs illustrating the behavior for various damping coefficients, driving amplitudes, and frequencies. 3 . Phase portraits, Poincar\u00e9 sections, and bifurcation diagrams. 4 . Discussion of the model's limitations and potential extensions. 1.3 Theoretical Foundation Governing Equation The motion of a forced damped pendulum is governed by the following nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t), \\] where: - \\(\\theta\\) : Angular displacement - \\(\\beta\\) : Damping coefficient - \\(\\omega_0\\) : Natural frequency of the pendulum - \\(A\\) : Amplitude of the external driving force - \\(\\omega\\) : Driving frequency Small-Angle Approximation For small angles ( \\(\\sin(\\theta) \\approx \\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t). \\] Solutions in this regime can be analyzed to explore resonance conditions and the system's energy response. Resonance Conditions Resonance occurs when the driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0\\) , resulting in maximum energy transfer and amplitude growth (limited by damping). 2. Analysis of Dynamics Parameter Influence 1 . Damping Coefficient ( \\(\\beta\\) ) : - High damping suppresses oscillations and prevents resonance. - Low damping allows larger amplitudes and increases the likelihood of chaotic transitions. 2 . Driving Amplitude ( \\(A\\) ) : - Larger amplitudes introduce stronger nonlinear effects and chaotic behavior. 3 . Driving Frequency ( \\(\\omega\\) ) : - Determines resonance and synchronization phenomena. Regular vs Chaotic Motion 1 . Chaotic motion arises as parameters transition through critical thresholds. 2 . This can be visualized using tools like phase portraits and Poincar\u00e9 sections. 3. Practical Applications Real-World Scenarios - Energy Harvesting Devices: Optimize oscillations for maximum energy extraction. - Suspension Bridges: Analyze and mitigate resonance-induced failures. - Oscillating Circuits: Model electrical analogs of forced damped systems. 4. Implementation Python Simulation Below is a Python script to simulate and visualize the motion of a forced damped pendulum: import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from scipy.integrate import solve_ivp # Computing the derivatives for the forced damped pendulum. def forced_damped_pendulum(t, y, beta, omega_0, A, omega): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -beta * omega_theta - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Simulates the forced damped pendulum. def simulate_pendulum(beta, omega_0, A, omega, theta0, omega_theta0, t_span, t_eval): y0 = [theta0, omega_theta0] sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(beta, omega_0, A, omega)) if not sol.success: raise RuntimeError(\"ODE solver failed.\") return sol.t, sol.y # Plot of the phase portrait of the pendulum. def plot_phase_portrait(theta, omega_theta): plt.figure(figsize=(8, 6)) plt.plot(theta, omega_theta, color=\"teal\", lw=1.2) plt.xlabel(\"Angular Displacement (\u03b8)\") plt.ylabel(\"Angular Velocity (\u03c9)\") plt.title(\"Phase Portrait of Forced Damped Pendulum\") plt.grid() plt.show() # Plots the time series of angular displacement. def plot_time_series(t, theta): plt.figure(figsize=(10, 6)) plt.plot(t, theta, color=\"purple\", lw=1.2) plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (\u03b8)\") plt.title(\"Time Series of Forced Damped Pendulum\") plt.grid() plt.show() # 3D Plot of phase with time as the third axis. def plot_3d_phase(t, theta, omega_theta): fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(theta, omega_theta, t, color=\"navy\", lw=1.2) ax.set_xlabel(\"Angular Displacement (\u03b8)\") ax.set_ylabel(\"Angular Velocity (\u03c9)\") ax.set_zlabel(\"Time (s)\") ax.set_title(\"3D Phase Plot of Forced Damped Pendulum\") plt.show() # Parameters params = { \"beta\": 0.5, # Damping coefficient \"omega_0\": 1.5, # Natural frequency \"A\": 1.2, # Driving amplitude \"omega\": 0.8, # Driving frequency \"theta0\": 0.2, # Initial displacement (radians) \"omega_theta0\": 0, # Initial angular velocity \"t_span\": (0, 50), # Time span for simulation \"t_eval\": np.linspace(0, 50, 2000) # Time points for evaluation } # Simulate t, y = simulate_pendulum(**params) theta, omega_theta = y # Visualize plot_time_series(t, theta) plot_phase_portrait(theta, omega_theta) plot_3d_phase(t, theta, omega_theta) 5. Discussion Limitations - Small-Angle Assumption: Only valid for \\(\\theta \\ll 1\\) radians. - Idealized Driving Force: Assumes a perfectly periodic external force. - Linear Damping: Real-world damping may be nonlinear. Extensions - Nonlinear Damping: Incorporate velocity-dependent damping terms. - Non-Periodic Forcing: Explore the effects of stochastic or quasiperiodic driving forces. - Coupled Pendulums: Investigate interactions between multiple driven pendulums. This analysis showcases the fascinating dynamics of forced damped pendulums and provides a foundation for exploring real-world applications and complex behaviors.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-motivation","text":"The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena serve as a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. By systematically varying these parameters, a diverse class of solutions can be observed, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications such as energy harvesting, vibration isolation, and mechanical resonance.","title":"1.1 Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-deliverables","text":"1 . A Python script implementing the simulation of a forced damped pendulum. 2 . Graphs illustrating the behavior for various damping coefficients, driving amplitudes, and frequencies. 3 . Phase portraits, Poincar\u00e9 sections, and bifurcation diagrams. 4 . Discussion of the model's limitations and potential extensions.","title":"1.2 Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-theoretical-foundation","text":"","title":"1.3 Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the following nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t), \\] where: - \\(\\theta\\) : Angular displacement - \\(\\beta\\) : Damping coefficient - \\(\\omega_0\\) : Natural frequency of the pendulum - \\(A\\) : Amplitude of the external driving force - \\(\\omega\\) : Driving frequency","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\(\\sin(\\theta) \\approx \\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t). \\] Solutions in this regime can be analyzed to explore resonance conditions and the system's energy response.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0\\) , resulting in maximum energy transfer and amplitude growth (limited by damping).","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-influence","text":"1 . Damping Coefficient ( \\(\\beta\\) ) : - High damping suppresses oscillations and prevents resonance. - Low damping allows larger amplitudes and increases the likelihood of chaotic transitions. 2 . Driving Amplitude ( \\(A\\) ) : - Larger amplitudes introduce stronger nonlinear effects and chaotic behavior. 3 . Driving Frequency ( \\(\\omega\\) ) : - Determines resonance and synchronization phenomena.","title":"Parameter Influence"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"1 . Chaotic motion arises as parameters transition through critical thresholds. 2 . This can be visualized using tools like phase portraits and Poincar\u00e9 sections.","title":"Regular vs Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#real-world-scenarios","text":"- Energy Harvesting Devices: Optimize oscillations for maximum energy extraction. - Suspension Bridges: Analyze and mitigate resonance-induced failures. - Oscillating Circuits: Model electrical analogs of forced damped systems.","title":"Real-World Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-simulation","text":"Below is a Python script to simulate and visualize the motion of a forced damped pendulum: import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from scipy.integrate import solve_ivp # Computing the derivatives for the forced damped pendulum. def forced_damped_pendulum(t, y, beta, omega_0, A, omega): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -beta * omega_theta - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Simulates the forced damped pendulum. def simulate_pendulum(beta, omega_0, A, omega, theta0, omega_theta0, t_span, t_eval): y0 = [theta0, omega_theta0] sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(beta, omega_0, A, omega)) if not sol.success: raise RuntimeError(\"ODE solver failed.\") return sol.t, sol.y # Plot of the phase portrait of the pendulum. def plot_phase_portrait(theta, omega_theta): plt.figure(figsize=(8, 6)) plt.plot(theta, omega_theta, color=\"teal\", lw=1.2) plt.xlabel(\"Angular Displacement (\u03b8)\") plt.ylabel(\"Angular Velocity (\u03c9)\") plt.title(\"Phase Portrait of Forced Damped Pendulum\") plt.grid() plt.show() # Plots the time series of angular displacement. def plot_time_series(t, theta): plt.figure(figsize=(10, 6)) plt.plot(t, theta, color=\"purple\", lw=1.2) plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (\u03b8)\") plt.title(\"Time Series of Forced Damped Pendulum\") plt.grid() plt.show() # 3D Plot of phase with time as the third axis. def plot_3d_phase(t, theta, omega_theta): fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(theta, omega_theta, t, color=\"navy\", lw=1.2) ax.set_xlabel(\"Angular Displacement (\u03b8)\") ax.set_ylabel(\"Angular Velocity (\u03c9)\") ax.set_zlabel(\"Time (s)\") ax.set_title(\"3D Phase Plot of Forced Damped Pendulum\") plt.show() # Parameters params = { \"beta\": 0.5, # Damping coefficient \"omega_0\": 1.5, # Natural frequency \"A\": 1.2, # Driving amplitude \"omega\": 0.8, # Driving frequency \"theta0\": 0.2, # Initial displacement (radians) \"omega_theta0\": 0, # Initial angular velocity \"t_span\": (0, 50), # Time span for simulation \"t_eval\": np.linspace(0, 50, 2000) # Time points for evaluation } # Simulate t, y = simulate_pendulum(**params) theta, omega_theta = y # Visualize plot_time_series(t, theta) plot_phase_portrait(theta, omega_theta) plot_3d_phase(t, theta, omega_theta)","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-discussion","text":"","title":"5. Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"- Small-Angle Assumption: Only valid for \\(\\theta \\ll 1\\) radians. - Idealized Driving Force: Assumes a perfectly periodic external force. - Linear Damping: Real-world damping may be nonlinear.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extensions","text":"- Nonlinear Damping: Incorporate velocity-dependent damping terms. - Non-Periodic Forcing: Explore the effects of stochastic or quasiperiodic driving forces. - Coupled Pendulums: Investigate interactions between multiple driven pendulums. This analysis showcases the fascinating dynamics of forced damped pendulums and provides a foundation for exploring real-world applications and complex behaviors.","title":"Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1.1 Motivation Kepler's Third Law, which relates the square of the orbital period to the cube of the orbital radius for celestial bodies, is a foundational principle in celestial mechanics. This elegant relationship not only underpins our understanding of planetary motion but also provides a crucial tool for determining masses and distances within planetary systems. From calculating the properties of satellite orbits to probing the dynamics of exoplanetary systems, Kepler's Third Law is indispensable. 1.2 Deliverables \\(1.\\) Markdown Document: Explanation of Kepler's Third Law and its derivation. \\(2.\\) Python Script: Computational model for circular orbits. \\(3.\\) Graphical Representations: - Log plot of orbital period vs radius. - Verification plot of Kepler's constant. 1.3 Theoretical Foundation Derivation of Kepler's Third Law Consider a celestial body of mass \\( m \\) orbiting a central body of mass \\( M \\) in a circular orbit of radius \\( r \\) . The centripetal force required for the orbit is provided by gravitational attraction: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\((G)\\) is the gravitational constant - \\((M)\\) is the mass of the central body - \\((m)\\) is the mass of the orbiting body - \\((r)\\) is the orbital radius The centripetal force is also expressed as: \\[ F = \\frac{m v^2}{r} \\] Equating these two expressions: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify to solve for \\(( v )\\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(( T )\\) is related to the orbital velocity \\(( v )\\) and radius \\(( r )\\) by: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(( v = \\sqrt{\\frac{G M}{r}} )\\) : \\[ T = \\frac{2 \\pi r}{\\sqrt{\\frac{G M}{r}}} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides yields Kepler's Third Law: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] 2. Implications for Astronomy Applications 1 . Planetary Masses: By observing orbital periods and radii, one can deduce the mass of the central body (e.g., the Sun or Earth). 2 . Distance Measurement: Kepler's Law aids in determining distances between celestial bodies, which is crucial for mapping planetary systems. Examples - The Moon's Orbit: Using the Moon's orbital period and radius, one can calculate Earth's mass. - Planetary Orbits: Applying Kepler's Third Law to the Solar System planets provides accurate orbital properties. 3. Computational Implementation Python Simulation Below is a Python script to simulate circular orbits and verify Kepler's Third Law: import numpy as np import matplotlib.pyplot as plt # Gravitational constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Mass of the central body (e.g., Sun in kg) M = 1.989e30 # Orbital radii (meters) orbits = np.logspace(9, 12, num=100) # Range of orbital radii # Compute orbital periods (seconds) periods = 2 * np.pi * np.sqrt(orbits**3 / (G * M)) # Verify Kepler's Third Law (T^2 / r^3 = constant) kepler_constant = periods**2 / orbits**3 # Plot orbital period vs orbital radius plt.figure(figsize=(10, 6)) plt.loglog(orbits, periods, label=\"Orbital Period\") plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period (s)\") plt.title(\"Orbital Period vs Orbital Radius\") plt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5) plt.legend() plt.show() # Plot Kepler's constant to check consistency plt.figure(figsize=(10, 6)) plt.plot(orbits, kepler_constant, label=\"Kepler's Constant\") plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"T^2 / r^3\") plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.show() 4. Discussion Extensions - Elliptical Orbits: Kepler's Third Law can be generalized for elliptical orbits by replacing \\( r \\) with the semi-major axis. - Non-Point Masses: Considerations for binary systems or extended mass distributions. Limitations - Simplifications: Assumes circular orbits and point masses. - Perturbations: Neglects gravitational influences from other bodies or relativistic effects. By combining theoretical insights with computational tools, the profound simplicity and utility of Kepler's Third Law can be effectively explored and applied to celestial mechanics.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-motivation","text":"Kepler's Third Law, which relates the square of the orbital period to the cube of the orbital radius for celestial bodies, is a foundational principle in celestial mechanics. This elegant relationship not only underpins our understanding of planetary motion but also provides a crucial tool for determining masses and distances within planetary systems. From calculating the properties of satellite orbits to probing the dynamics of exoplanetary systems, Kepler's Third Law is indispensable.","title":"1.1 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#12-deliverables","text":"\\(1.\\) Markdown Document: Explanation of Kepler's Third Law and its derivation. \\(2.\\) Python Script: Computational model for circular orbits. \\(3.\\) Graphical Representations: - Log plot of orbital period vs radius. - Verification plot of Kepler's constant.","title":"1.2 Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/#13-theoretical-foundation","text":"","title":"1.3 Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"Consider a celestial body of mass \\( m \\) orbiting a central body of mass \\( M \\) in a circular orbit of radius \\( r \\) . The centripetal force required for the orbit is provided by gravitational attraction: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\((G)\\) is the gravitational constant - \\((M)\\) is the mass of the central body - \\((m)\\) is the mass of the orbiting body - \\((r)\\) is the orbital radius The centripetal force is also expressed as: \\[ F = \\frac{m v^2}{r} \\] Equating these two expressions: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify to solve for \\(( v )\\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(( T )\\) is related to the orbital velocity \\(( v )\\) and radius \\(( r )\\) by: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(( v = \\sqrt{\\frac{G M}{r}} )\\) : \\[ T = \\frac{2 \\pi r}{\\sqrt{\\frac{G M}{r}}} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides yields Kepler's Third Law: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\]","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications","text":"1 . Planetary Masses: By observing orbital periods and radii, one can deduce the mass of the central body (e.g., the Sun or Earth). 2 . Distance Measurement: Kepler's Law aids in determining distances between celestial bodies, which is crucial for mapping planetary systems.","title":"Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#examples","text":"- The Moon's Orbit: Using the Moon's orbital period and radius, one can calculate Earth's mass. - Planetary Orbits: Applying Kepler's Third Law to the Solar System planets provides accurate orbital properties.","title":"Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-computational-implementation","text":"","title":"3. Computational Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"Below is a Python script to simulate circular orbits and verify Kepler's Third Law: import numpy as np import matplotlib.pyplot as plt # Gravitational constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Mass of the central body (e.g., Sun in kg) M = 1.989e30 # Orbital radii (meters) orbits = np.logspace(9, 12, num=100) # Range of orbital radii # Compute orbital periods (seconds) periods = 2 * np.pi * np.sqrt(orbits**3 / (G * M)) # Verify Kepler's Third Law (T^2 / r^3 = constant) kepler_constant = periods**2 / orbits**3 # Plot orbital period vs orbital radius plt.figure(figsize=(10, 6)) plt.loglog(orbits, periods, label=\"Orbital Period\") plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period (s)\") plt.title(\"Orbital Period vs Orbital Radius\") plt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5) plt.legend() plt.show() # Plot Kepler's constant to check consistency plt.figure(figsize=(10, 6)) plt.plot(orbits, kepler_constant, label=\"Kepler's Constant\") plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"T^2 / r^3\") plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-discussion","text":"","title":"4. Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extensions","text":"- Elliptical Orbits: Kepler's Third Law can be generalized for elliptical orbits by replacing \\( r \\) with the semi-major axis. - Non-Point Masses: Considerations for binary systems or extended mass distributions.","title":"Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#limitations","text":"- Simplifications: Assumes circular orbits and point masses. - Perturbations: Neglects gravitational influences from other bodies or relativistic effects. By combining theoretical insights with computational tools, the profound simplicity and utility of Kepler's Third Law can be effectively explored and applied to celestial mechanics.","title":"Limitations"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1.1 Motivation The concept of escape velocity is fundamental in astrophysics and space exploration. It defines the minimum speed an object must reach to overcome the gravitational influence of a celestial body without additional propulsion. Extending this concept further, the first, second, and third cosmic velocities describe the thresholds for orbiting a planet, escaping a planet's gravitational pull, and escaping a star system, respectively. These concepts are critical in designing satellite launches, interplanetary missions, and potential interstellar travel. 1.2 Deliverables 1 . Markdown Document : Detailed explanation of escape and cosmic velocities. 2 . Python Script : Computational model to calculate and visualize the velocities. 3 . Graphical Representations : Bar chart comparing first and second cosmic velocities for Earth, Mars, and Jupiter. 1.3 Theoretical Foundation Definitions and Physical Meanings First Cosmic Velocity : The velocity required for an object to maintain a stable circular orbit around a celestial body. \\[v_1 = \\sqrt{\\frac{G M}{r}}\\] Where: - \\((G)\\) : Gravitational constant - \\((M)\\) : Mass of the celestial body - \\((r)\\) : Radius of the orbit (distance from the center of the body) 2 . Second Cosmic Velocity (Escape Velocity) : The velocity required to escape the gravitational field of a celestial body. $$ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2 G M}{r}} $$ 3 . Third Cosmic Velocity : The velocity required to escape the gravitational influence of a star system. $$ v_3 = \\sqrt{v_2^2 + \\frac{2 G M_{\\text{star}}}{r}} $$ Where \\(M_{\\text{star}}\\) is the mass of the central star. 2. Mathematical Analysis Parameters Influencing Cosmic Velocities - Mass \\(( M )\\) : Higher mass increases the gravitational pull, raising all three velocities. - Radius \\(( r )\\) : Greater distances from the center of the celestial body reduce the gravitational force, lowering the velocities. - Gravitational Constant \\(( G )\\) : A universal constant influencing the strength of gravity. Calculations for Earth, Mars, and Jupiter Example Values: - Earth : \\(( M = 5.972 \\times 10^{24} \\ \\text{kg}, r = 6.371 \\times 10^{6} \\ \\text{m} )\\) - Mars : \\(( M = 6.39 \\times 10^{23} \\ \\text{kg}, r = 3.39 \\times 10^{6} \\ \\text{m} )\\) - Jupiter : \\(( M = 1.898 \\times 10^{27} \\ \\text{kg}, r = 6.99 \\times 10^{7} \\ \\text{m} )\\) 3. Computational Implementation Python Script import numpy as np import matplotlib.pyplot as plt # Gravitational constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Define celestial bodies data = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.39e23, \"radius\": 3.39e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.99e7}, } # Calculate velocities results = {} for planet, values in data.items(): mass = values[\"mass\"] radius = values[\"radius\"] v1 = np.sqrt(G * mass / radius) # First cosmic velocity v2 = np.sqrt(2) * v1 # Second cosmic velocity results[planet] = {\"v1\": v1, \"v2\": v2} # Display results for planet, velocities in results.items(): print(f\"{planet}: First Cosmic Velocity = {velocities['v1']:.2f} m/s, Second Cosmic Velocity = {velocities['v2']:.2f} m/s\") # Visualization labels = list(results.keys()) v1_values = [results[planet][\"v1\"] for planet in labels] v2_values = [results[planet][\"v2\"] for planet in labels] x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots() bar1 = ax.bar(x - width/2, v1_values, width, label=\"First Cosmic Velocity\") bar2 = ax.bar(x + width/2, v2_values, width, label=\"Second Cosmic Velocity\") ax.set_xlabel(\"Planet\") ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"Cosmic Velocities for Different Celestial Bodies\") ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.tight_layout() plt.show() 4. Discussion Importance in Space Exploration - Launching Satellites : The first cosmic velocity determines the minimum speed required for satellites to orbit Earth. - Interplanetary Missions : The second cosmic velocity is critical for missions escaping Earth's gravitational pull, such as journeys to Mars. - Interstellar Travel : The third cosmic velocity underpins the feasibility of missions beyond our solar system. Limitations and Extensions - Simplifications : Assumes point masses and neglects factors like atmospheric drag or relativistic effects. - Extensions : Explore scenarios with varying atmospheric densities or gravitational influences from multiple bodies. Understanding cosmic velocities is not only a theoretical exercise but also a practical necessity in advancing humanity's reach into space. This framework forms the foundation for the precise calculations required in modern space exploration.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-motivation","text":"The concept of escape velocity is fundamental in astrophysics and space exploration. It defines the minimum speed an object must reach to overcome the gravitational influence of a celestial body without additional propulsion. Extending this concept further, the first, second, and third cosmic velocities describe the thresholds for orbiting a planet, escaping a planet's gravitational pull, and escaping a star system, respectively. These concepts are critical in designing satellite launches, interplanetary missions, and potential interstellar travel.","title":"1.1 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-deliverables","text":"1 . Markdown Document : Detailed explanation of escape and cosmic velocities. 2 . Python Script : Computational model to calculate and visualize the velocities. 3 . Graphical Representations : Bar chart comparing first and second cosmic velocities for Earth, Mars, and Jupiter.","title":"1.2 Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-theoretical-foundation","text":"","title":"1.3 Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-physical-meanings","text":"First Cosmic Velocity : The velocity required for an object to maintain a stable circular orbit around a celestial body. \\[v_1 = \\sqrt{\\frac{G M}{r}}\\] Where: - \\((G)\\) : Gravitational constant - \\((M)\\) : Mass of the celestial body - \\((r)\\) : Radius of the orbit (distance from the center of the body) 2 . Second Cosmic Velocity (Escape Velocity) : The velocity required to escape the gravitational field of a celestial body. $$ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2 G M}{r}} $$ 3 . Third Cosmic Velocity : The velocity required to escape the gravitational influence of a star system. $$ v_3 = \\sqrt{v_2^2 + \\frac{2 G M_{\\text{star}}}{r}} $$ Where \\(M_{\\text{star}}\\) is the mass of the central star.","title":"Definitions and Physical Meanings"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-analysis","text":"","title":"2. Mathematical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-influencing-cosmic-velocities","text":"- Mass \\(( M )\\) : Higher mass increases the gravitational pull, raising all three velocities. - Radius \\(( r )\\) : Greater distances from the center of the celestial body reduce the gravitational force, lowering the velocities. - Gravitational Constant \\(( G )\\) : A universal constant influencing the strength of gravity.","title":"Parameters Influencing Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-earth-mars-and-jupiter","text":"","title":"Calculations for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#example-values","text":"- Earth : \\(( M = 5.972 \\times 10^{24} \\ \\text{kg}, r = 6.371 \\times 10^{6} \\ \\text{m} )\\) - Mars : \\(( M = 6.39 \\times 10^{23} \\ \\text{kg}, r = 3.39 \\times 10^{6} \\ \\text{m} )\\) - Jupiter : \\(( M = 1.898 \\times 10^{27} \\ \\text{kg}, r = 6.99 \\times 10^{7} \\ \\text{m} )\\)","title":"Example Values:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-computational-implementation","text":"","title":"3. Computational Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-script","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Define celestial bodies data = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.39e23, \"radius\": 3.39e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.99e7}, } # Calculate velocities results = {} for planet, values in data.items(): mass = values[\"mass\"] radius = values[\"radius\"] v1 = np.sqrt(G * mass / radius) # First cosmic velocity v2 = np.sqrt(2) * v1 # Second cosmic velocity results[planet] = {\"v1\": v1, \"v2\": v2} # Display results for planet, velocities in results.items(): print(f\"{planet}: First Cosmic Velocity = {velocities['v1']:.2f} m/s, Second Cosmic Velocity = {velocities['v2']:.2f} m/s\") # Visualization labels = list(results.keys()) v1_values = [results[planet][\"v1\"] for planet in labels] v2_values = [results[planet][\"v2\"] for planet in labels] x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots() bar1 = ax.bar(x - width/2, v1_values, width, label=\"First Cosmic Velocity\") bar2 = ax.bar(x + width/2, v2_values, width, label=\"Second Cosmic Velocity\") ax.set_xlabel(\"Planet\") ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"Cosmic Velocities for Different Celestial Bodies\") ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.tight_layout() plt.show()","title":"Python Script"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-discussion","text":"","title":"4. Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"- Launching Satellites : The first cosmic velocity determines the minimum speed required for satellites to orbit Earth. - Interplanetary Missions : The second cosmic velocity is critical for missions escaping Earth's gravitational pull, such as journeys to Mars. - Interstellar Travel : The third cosmic velocity underpins the feasibility of missions beyond our solar system.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#limitations-and-extensions","text":"- Simplifications : Assumes point masses and neglects factors like atmospheric drag or relativistic effects. - Extensions : Explore scenarios with varying atmospheric densities or gravitational influences from multiple bodies. Understanding cosmic velocities is not only a theoretical exercise but also a practical necessity in advancing humanity's reach into space. This framework forms the foundation for the precise calculations required in modern space exploration.","title":"Limitations and Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory is determined by the interplay of initial conditions and gravitational forces. This scenario blends principles of orbital mechanics with computational techniques to solve complex motion equations. Understanding these trajectories is essential for space mission operations, such as deploying payloads into orbit or ensuring safe reentry to Earth. Deliverables 1 . Markdown Document: Detailed explanation of trajectory analysis. 2 . Python Script: Numerical simulation of payload motion. 3 . Graphical Representations: - Orbital trajectories for different initial velocities and positions. - Comparison of parabolic, hyperbolic, and elliptical trajectories. Theoretical Foundation Governing Equations The motion of a payload near Earth can be described using Newton's Law of Gravitation: \\[ F = \\frac{G M m}{r^2}, \\] Where: \\((G)\\) is the gravitational constant \\((M)\\) is Earth's mass \\((m)\\) is the payload's mass \\((r)\\) is the distance between the payload and Earth's center The acceleration due to gravity is given by: \\[ a = \\frac{F}{m} = \\frac{G M}{r^2}. \\] Using Newton's Second Law, the equations of motion for the payload in Cartesian coordinates \\((x, y)\\) are: \\[ \\ddot{x} = -\\frac{G M x}{r^3}, \\quad \\ddot{y} = - \\frac{G M y}{r^3} \\] Where \\(( r = \\sqrt{x^2 + y^2} )\\) . Trajectory Classification The type of trajectory depends on the total energy \\(( E )\\) of the system: - Elliptical: \\(( E < 0 )\\) - Parabolic: \\(( E = 0 )\\) - Hyperbolic: \\(( E > 0 )\\) The energy is given by: \\[ E = \\frac{1}{2}mv^2 - \\frac{G M m}{r}. \\] Computational Implementation Numerical Simulation Using numerical methods, such as the Runge-Kutta algorithm, we can compute the payload\u2019s trajectory based on its initial position and velocity. Python Script import numpy as np import matplotlib.pyplot as plt # Gravitational constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Mass of Earth (kg) M = 5.972e24 # Earth's radius (m) R_earth = 6.371e6 # Time step and duration dt = 1 # seconds simulation_time = 3600 # seconds # Initial conditions (position in meters, velocity in m/s) initial_position = np.array([R_earth + 500e3, 0]) # 500 km altitude initial_velocity = np.array([0, 7500]) # near-orbital velocity # Initialize arrays for position and velocity position = [initial_position] velocity = [initial_velocity] # Function to compute acceleration def acceleration(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # Numerical integration loop for _ in range(int(simulation_time / dt)): current_pos = position[-1] current_vel = velocity[-1] # Compute acceleration acc = acceleration(current_pos) # Update velocity and position using Euler's method new_vel = current_vel + acc * dt new_pos = current_pos + new_vel * dt velocity.append(new_vel) position.append(new_pos) # Convert to numpy arrays position = np.array(position) # Plot trajectory plt.figure(figsize=(8, 8)) plt.plot(position[:, 0], position[:, 1], label=\"Payload Trajectory\") plt.scatter(0, 0, color=\"blue\", label=\"Earth\", s=500) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Payload Trajectory Near Earth\") plt.legend() plt.grid() plt.axis('equal') plt.show() Discussion Applications - Orbital Insertion: Achieving stable orbits for satellites. - Reentry Analysis: Predicting paths for safe reentry of payloads. - Escape Scenarios: Determining conditions for interplanetary missions. Limitations - Simplifications: Assumes a point-mass Earth and neglects atmospheric drag. - Perturbations: Ignores gravitational effects from other celestial bodies. By analyzing the dynamics of a payload released near Earth, we can gain deeper insights into orbital mechanics and enhance the design of space missions.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory is determined by the interplay of initial conditions and gravitational forces. This scenario blends principles of orbital mechanics with computational techniques to solve complex motion equations. Understanding these trajectories is essential for space mission operations, such as deploying payloads into orbit or ensuring safe reentry to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#deliverables","text":"1 . Markdown Document: Detailed explanation of trajectory analysis. 2 . Python Script: Numerical simulation of payload motion. 3 . Graphical Representations: - Orbital trajectories for different initial velocities and positions. - Comparison of parabolic, hyperbolic, and elliptical trajectories.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"The motion of a payload near Earth can be described using Newton's Law of Gravitation: \\[ F = \\frac{G M m}{r^2}, \\] Where: \\((G)\\) is the gravitational constant \\((M)\\) is Earth's mass \\((m)\\) is the payload's mass \\((r)\\) is the distance between the payload and Earth's center The acceleration due to gravity is given by: \\[ a = \\frac{F}{m} = \\frac{G M}{r^2}. \\] Using Newton's Second Law, the equations of motion for the payload in Cartesian coordinates \\((x, y)\\) are: \\[ \\ddot{x} = -\\frac{G M x}{r^3}, \\quad \\ddot{y} = - \\frac{G M y}{r^3} \\] Where \\(( r = \\sqrt{x^2 + y^2} )\\) .","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-classification","text":"The type of trajectory depends on the total energy \\(( E )\\) of the system: - Elliptical: \\(( E < 0 )\\) - Parabolic: \\(( E = 0 )\\) - Hyperbolic: \\(( E > 0 )\\) The energy is given by: \\[ E = \\frac{1}{2}mv^2 - \\frac{G M m}{r}. \\]","title":"Trajectory Classification"},{"location":"1%20Physics/2%20Gravity/Problem_3/#computational-implementation","text":"","title":"Computational Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"Using numerical methods, such as the Runge-Kutta algorithm, we can compute the payload\u2019s trajectory based on its initial position and velocity.","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-script","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Mass of Earth (kg) M = 5.972e24 # Earth's radius (m) R_earth = 6.371e6 # Time step and duration dt = 1 # seconds simulation_time = 3600 # seconds # Initial conditions (position in meters, velocity in m/s) initial_position = np.array([R_earth + 500e3, 0]) # 500 km altitude initial_velocity = np.array([0, 7500]) # near-orbital velocity # Initialize arrays for position and velocity position = [initial_position] velocity = [initial_velocity] # Function to compute acceleration def acceleration(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # Numerical integration loop for _ in range(int(simulation_time / dt)): current_pos = position[-1] current_vel = velocity[-1] # Compute acceleration acc = acceleration(current_pos) # Update velocity and position using Euler's method new_vel = current_vel + acc * dt new_pos = current_pos + new_vel * dt velocity.append(new_vel) position.append(new_pos) # Convert to numpy arrays position = np.array(position) # Plot trajectory plt.figure(figsize=(8, 8)) plt.plot(position[:, 0], position[:, 1], label=\"Payload Trajectory\") plt.scatter(0, 0, color=\"blue\", label=\"Earth\", s=500) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Payload Trajectory Near Earth\") plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"Python Script"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion","text":"","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#applications","text":"- Orbital Insertion: Achieving stable orbits for satellites. - Reentry Analysis: Predicting paths for safe reentry of payloads. - Escape Scenarios: Determining conditions for interplanetary missions.","title":"Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#limitations","text":"- Simplifications: Assumes a point-mass Earth and neglects atmospheric drag. - Perturbations: Ignores gravitational effects from other celestial bodies. By analyzing the dynamics of a payload released near Earth, we can gain deeper insights into orbital mechanics and enhance the design of space missions.","title":"Limitations"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be observed when ripples from different points meet, forming distinctive interference patterns. These patterns help us understand wave behavior, the relationship between wave phase, and the effects of multiple sources. Studying interference is both an intuitive and practical way to learn about wave physics. Problem Statement Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources positioned at the vertices of a chosen regular polygon. Deliverables 1 . Markdown Document: Explaining interference and implementation. 2 . Python Script/Notebook: Code to simulate interference patterns. 3 . Graphical Visualizations: Contour plots for different polygon configurations. 4 . Analysis: Discussion of how polygon geometry affects interference patterns. Single Wave Equation: A circular wave on a water surface, emanating from a point source located at \\(r_i\\) , is described by: $$ \\eta(r, t) = A \\cos(k r - \\omega t + \\phi) $$ Where: - \\(\\eta(r, t)\\) : Displacement of the water surface at point \\(r\\) and time \\(t\\) . - \\(A\\) : Amplitude of the wave. - \\(k\\) : Wave number \\((k = \\frac{2\\pi}{\\lambda})\\) . - \\(\\omega\\) : Angular frequency \\((\\omega = 2\\pi f)\\) . - \\(r\\) : Distance from the source to the point. - \\(\\phi\\) : Initial phase. Superposition Principle: For \\(N\\) sources placed at positions \\(r_i\\) , the total displacement is: $$ \\eta_{\\text{total}}(r, t) = \\sum_{i=1}^{N} A \\cos(k |r - r_i| - \\omega t + \\phi) $$ Task Objectives: 1 . Select a Regular Polygon : Place wave sources at its vertices. 2 . Position the Sources : Use geometry to calculate vertex positions. 3 . Wave Equations : Define the displacement for each source. 4 . Superposition : Sum displacements from all sources. 5 . Analyze Patterns : Identify regions of constructive and destructive interference. 6 . Visualize : Create plots showing interference patterns. Steps Step 1: Select a Regular Polygon - Choose a regular polygon (e.g., equilateral triangle, square, pentagon). - Vertices represent the wave source positions. Step 2: Position the Sources Calculate vertex positions using polar coordinates: \\[ r_i = R \\cdot e^{i \\frac{2\\pi i}{n}} \\] - \\(R\\) : Radius of the polygon. - \\(n\\) : Number of vertices (sources). - \\(i\\) : Vertex index. Step 3: Write the Wave Equations For a source at \\(r_i\\) : $$ \\eta_i(r, t) = A \\cos(k |r - r_i| - \\omega t + \\phi) $$ Step 4: Apply Superposition of Waves Combine the displacements of all sources: $$ \\eta_{\\text{total}}(r, t) = \\sum_{i=1}^{N} \\eta_i(r, t) $$ Step 5: Analyze the Patterns Visualize regions of: - Constructive interference : Waves reinforce each other. - Destructive interference : Waves cancel each other out. Step 6: Visualization Generate contour plots showing the interference patterns for different polygon configurations. Implementation in Python import numpy as np import matplotlib.pyplot as plt # Constants A = 1 # Amplitude k = 2 * np.pi / 1 # Wave number (assuming wavelength = 1) omega = 2 * np.pi * 1 # Angular frequency (assuming frequency = 1) R = 5 # Radius of the polygon n = 4 # Number of sources (vertices of polygon, e.g., square) def wave_displacement(r, r_i, A, k, omega, t, phi): distance = np.linalg.norm(r - r_i) return A * np.cos(k * distance - omega * t + phi) def polygon_sources(R, n): angles = np.linspace(0, 2 * np.pi, n, endpoint=False) return np.array([(R * np.cos(angle), R * np.sin(angle)) for angle in angles]) # Create grid points x_vals = np.linspace(-10, 10, 100) y_vals = np.linspace(-10, 10, 100) X, Y = np.meshgrid(x_vals, y_vals) points = np.vstack([X.ravel(), Y.ravel()]).T # Source positions sources = polygon_sources(R, n) t = 0 # Time displacement = np.zeros(points.shape[0]) for i, point in enumerate(points): displacement_at_point = 0 for source in sources: displacement_at_point += wave_displacement(point, source, A, k, omega, t, 0) displacement[i] = displacement_at_point Z = displacement.reshape(X.shape) # Plot interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, 50, cmap='RdGy') plt.colorbar(label='Displacement') plt.title(f'Interference Pattern for {n}-Point Source Polygon') plt.xlabel('X') plt.ylabel('Y') plt.show() Explanation of the Code - Wave_displacement : This function computes the displacement at a given point \\(\ud835\udc5f\\) due to a wave source at \\(\ud835\udc5f_i\\) ,using the wave equation. - Polygon_sources : This function calculates the positions of the wave sources placed at the vertices of a regular polygon. - Superposition : For each point on the grid, we sum the displacements due to all wave sources to get the total displacement. - Visualization : The displacement values are plotted using contour plots to show regions of constructive and destructive interference.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be observed when ripples from different points meet, forming distinctive interference patterns. These patterns help us understand wave behavior, the relationship between wave phase, and the effects of multiple sources. Studying interference is both an intuitive and practical way to learn about wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources positioned at the vertices of a chosen regular polygon.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables","text":"1 . Markdown Document: Explaining interference and implementation. 2 . Python Script/Notebook: Code to simulate interference patterns. 3 . Graphical Visualizations: Contour plots for different polygon configurations. 4 . Analysis: Discussion of how polygon geometry affects interference patterns.","title":"Deliverables"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-wave-equation","text":"A circular wave on a water surface, emanating from a point source located at \\(r_i\\) , is described by: $$ \\eta(r, t) = A \\cos(k r - \\omega t + \\phi) $$ Where: - \\(\\eta(r, t)\\) : Displacement of the water surface at point \\(r\\) and time \\(t\\) . - \\(A\\) : Amplitude of the wave. - \\(k\\) : Wave number \\((k = \\frac{2\\pi}{\\lambda})\\) . - \\(\\omega\\) : Angular frequency \\((\\omega = 2\\pi f)\\) . - \\(r\\) : Distance from the source to the point. - \\(\\phi\\) : Initial phase.","title":"Single Wave Equation:"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-principle","text":"For \\(N\\) sources placed at positions \\(r_i\\) , the total displacement is: $$ \\eta_{\\text{total}}(r, t) = \\sum_{i=1}^{N} A \\cos(k |r - r_i| - \\omega t + \\phi) $$","title":"Superposition Principle:"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-objectives","text":"1 . Select a Regular Polygon : Place wave sources at its vertices. 2 . Position the Sources : Use geometry to calculate vertex positions. 3 . Wave Equations : Define the displacement for each source. 4 . Superposition : Sum displacements from all sources. 5 . Analyze Patterns : Identify regions of constructive and destructive interference. 6 . Visualize : Create plots showing interference patterns.","title":"Task Objectives:"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps","text":"","title":"Steps"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-1-select-a-regular-polygon","text":"- Choose a regular polygon (e.g., equilateral triangle, square, pentagon). - Vertices represent the wave source positions.","title":"Step 1: Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-2-position-the-sources","text":"Calculate vertex positions using polar coordinates: \\[ r_i = R \\cdot e^{i \\frac{2\\pi i}{n}} \\] - \\(R\\) : Radius of the polygon. - \\(n\\) : Number of vertices (sources). - \\(i\\) : Vertex index.","title":"Step 2: Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-3-write-the-wave-equations","text":"For a source at \\(r_i\\) : $$ \\eta_i(r, t) = A \\cos(k |r - r_i| - \\omega t + \\phi) $$","title":"Step 3: Write the Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-4-apply-superposition-of-waves","text":"Combine the displacements of all sources: $$ \\eta_{\\text{total}}(r, t) = \\sum_{i=1}^{N} \\eta_i(r, t) $$","title":"Step 4: Apply Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-5-analyze-the-patterns","text":"Visualize regions of: - Constructive interference : Waves reinforce each other. - Destructive interference : Waves cancel each other out.","title":"Step 5: Analyze the Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-6-visualization","text":"Generate contour plots showing the interference patterns for different polygon configurations.","title":"Step 6: Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#implementation-in-python","text":"import numpy as np import matplotlib.pyplot as plt # Constants A = 1 # Amplitude k = 2 * np.pi / 1 # Wave number (assuming wavelength = 1) omega = 2 * np.pi * 1 # Angular frequency (assuming frequency = 1) R = 5 # Radius of the polygon n = 4 # Number of sources (vertices of polygon, e.g., square) def wave_displacement(r, r_i, A, k, omega, t, phi): distance = np.linalg.norm(r - r_i) return A * np.cos(k * distance - omega * t + phi) def polygon_sources(R, n): angles = np.linspace(0, 2 * np.pi, n, endpoint=False) return np.array([(R * np.cos(angle), R * np.sin(angle)) for angle in angles]) # Create grid points x_vals = np.linspace(-10, 10, 100) y_vals = np.linspace(-10, 10, 100) X, Y = np.meshgrid(x_vals, y_vals) points = np.vstack([X.ravel(), Y.ravel()]).T # Source positions sources = polygon_sources(R, n) t = 0 # Time displacement = np.zeros(points.shape[0]) for i, point in enumerate(points): displacement_at_point = 0 for source in sources: displacement_at_point += wave_displacement(point, source, A, k, omega, t, 0) displacement[i] = displacement_at_point Z = displacement.reshape(X.shape) # Plot interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, 50, cmap='RdGy') plt.colorbar(label='Displacement') plt.title(f'Interference Pattern for {n}-Point Source Polygon') plt.xlabel('X') plt.ylabel('Y') plt.show()","title":"Implementation in Python"},{"location":"1%20Physics/3%20Waves/Problem_1/#explanation-of-the-code","text":"- Wave_displacement : This function computes the displacement at a given point \\(\ud835\udc5f\\) due to a wave source at \\(\ud835\udc5f_i\\) ,using the wave equation. - Polygon_sources : This function calculates the positions of the wave sources placed at the vertices of a regular polygon. - Superposition : For each point on the grid, we sum the displacements due to all wave sources to get the total displacement. - Visualization : The displacement values are plotted using contour plots to show regions of constructive and destructive interference.","title":"Explanation of the Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force, expressed as: $$ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) $$ governs the motion of charged particles in electric ( \\(\\vec{E}\\) ) and magnetic ( \\(\\vec{B}\\) ) fields. This fundamental principle is pivotal in plasma physics, particle accelerators, and astrophysics. By simulating these effects, we can explore practical applications and visualize complex trajectories of charged particles. Deliverables 1 . Markdown Document : Explaining the task and methodology. 2 . Python Script/Notebook : Implementation of the simulations. 3 . Visualizations : - Particle trajectories for specified field configurations. - 2D and 3D plots highlighting key physical phenomena. 4 . Discussion : - Relate results to practical systems like cyclotrons and magnetic traps. - Provide suggestions for extending the simulation to non-uniform fields. Tasks 1. Exploration of Applications 1 . Identify Systems : - Particle accelerators. - Mass spectrometers. - Plasma confinement systems. 2 . Discuss Field Relevance : - Analyze how electric ( \\(\\vec{E}\\) ) and magnetic ( \\(\\vec{B}\\) ) fields control particle motion. 2. Simulating Particle Motion Simulate the trajectory of a charged particle under various field conditions: 1 . Uniform Magnetic Field : Visualize circular motion. 2 . Combined Uniform Electric and Magnetic Fields : Analyze helical motion. 3 . Crossed Fields : Examine drift motion. 3. Parameter Exploration 1 . Field Strength Variations : Adjust \\(\\vec{E}\\) and \\(\\vec{B}\\) . 2 . Initial Velocity : Explore different values for \\(\\vec{v}_0\\) . 3 . Particle Properties : - Charge \\(q\\) . - Mass \\(m\\) . 4. Visualization 1 . Generate clear, labeled 2D and 3D plots. 2 . Highlight key phenomena like: - Larmor radius. - Drift velocity. 3 . Provide detailed explanations of the plots, emphasizing: - How the trajectory corresponds to physical principles. - The effect of different parameters (e.g., field strength, particle velocity) on the motion. - Differences in trajectories under various configurations (uniform \\(\\vec{B}\\) , combined \\(\\vec{E}\\) and \\(\\vec{B}\\) , crossed fields). Implementation in Python Numerical Methods - Use Euler or Runge-Kutta methods to solve equations of motion. - Employ libraries like NumPy for calculations and Matplotlib for visualization. Example Simulation (Uniform Magnetic Field) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants eq = 1.6e-19 # Charge of the particle (C) mass = 9.11e-31 # Mass of the particle (kg) B = 1.0 # Magnetic field strength (T) # Initial conditions v0 = 1e6 # Initial velocity (m/s) angle = np.pi / 4 # Angle of initial velocity with respect to the z-axis # Derived quantities omega = eq * B / mass # Cyclotron frequency radius = mass * v0 / (eq * B) # Radius of circular motion # Time parameters time = np.linspace(0, 1e-7, 1000) # Time array # 2D Trajectory (in x-y plane) x_2d = radius * np.cos(omega * time) y_2d = radius * np.sin(omega * time) # 3D Trajectory (with initial velocity at an angle to the z-axis) vz = v0 * np.cos(angle) # Z-component of velocity vr = v0 * np.sin(angle) # Radial velocity in the x-y plane z_3d = vz * time # Uniform motion along z-axis x_3d = radius * np.cos(omega * time) y_3d = radius * np.sin(omega * time) # Plotting the 2D Trajectory plt.figure(figsize=(8, 6)) plt.plot(x_2d, y_2d, label=\"2D Trajectory (x-y plane)\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"2D Trajectory of Charged Particle in Magnetic Field\") plt.grid() plt.axis(\"equal\") plt.legend() plt.show() # Plotting the 3D Trajectory fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(x_3d, y_3d, z_3d, label=\"3D Trajectory\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") ax.set_title(\"3D Trajectory of Charged Particle in Magnetic Field\") ax.legend() plt.show() Explanation of Visualization - The 3D plot demonstrates the trajectory of a charged particle in a uniform magnetic field. - Circular motion is observed due to the Lorentz force acting perpendicular to the particle's velocity, creating a centripetal force. - The radius of the trajectory (Larmor radius) depends on the particle's mass, charge, velocity, and the magnetic field strength. - Variations in initial conditions or field parameters would alter the shape and size of the trajectory, which can be explored by modifying the simulation parameters.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, expressed as: $$ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) $$ governs the motion of charged particles in electric ( \\(\\vec{E}\\) ) and magnetic ( \\(\\vec{B}\\) ) fields. This fundamental principle is pivotal in plasma physics, particle accelerators, and astrophysics. By simulating these effects, we can explore practical applications and visualize complex trajectories of charged particles.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"1 . Markdown Document : Explaining the task and methodology. 2 . Python Script/Notebook : Implementation of the simulations. 3 . Visualizations : - Particle trajectories for specified field configurations. - 2D and 3D plots highlighting key physical phenomena. 4 . Discussion : - Relate results to practical systems like cyclotrons and magnetic traps. - Provide suggestions for extending the simulation to non-uniform fields.","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#tasks","text":"","title":"Tasks"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"1 . Identify Systems : - Particle accelerators. - Mass spectrometers. - Plasma confinement systems. 2 . Discuss Field Relevance : - Analyze how electric ( \\(\\vec{E}\\) ) and magnetic ( \\(\\vec{B}\\) ) fields control particle motion.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"Simulate the trajectory of a charged particle under various field conditions: 1 . Uniform Magnetic Field : Visualize circular motion. 2 . Combined Uniform Electric and Magnetic Fields : Analyze helical motion. 3 . Crossed Fields : Examine drift motion.","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"1 . Field Strength Variations : Adjust \\(\\vec{E}\\) and \\(\\vec{B}\\) . 2 . Initial Velocity : Explore different values for \\(\\vec{v}_0\\) . 3 . Particle Properties : - Charge \\(q\\) . - Mass \\(m\\) .","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"1 . Generate clear, labeled 2D and 3D plots. 2 . Highlight key phenomena like: - Larmor radius. - Drift velocity. 3 . Provide detailed explanations of the plots, emphasizing: - How the trajectory corresponds to physical principles. - The effect of different parameters (e.g., field strength, particle velocity) on the motion. - Differences in trajectories under various configurations (uniform \\(\\vec{B}\\) , combined \\(\\vec{E}\\) and \\(\\vec{B}\\) , crossed fields).","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#implementation-in-python","text":"","title":"Implementation in Python"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#numerical-methods","text":"- Use Euler or Runge-Kutta methods to solve equations of motion. - Employ libraries like NumPy for calculations and Matplotlib for visualization.","title":"Numerical Methods"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#example-simulation-uniform-magnetic-field","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants eq = 1.6e-19 # Charge of the particle (C) mass = 9.11e-31 # Mass of the particle (kg) B = 1.0 # Magnetic field strength (T) # Initial conditions v0 = 1e6 # Initial velocity (m/s) angle = np.pi / 4 # Angle of initial velocity with respect to the z-axis # Derived quantities omega = eq * B / mass # Cyclotron frequency radius = mass * v0 / (eq * B) # Radius of circular motion # Time parameters time = np.linspace(0, 1e-7, 1000) # Time array # 2D Trajectory (in x-y plane) x_2d = radius * np.cos(omega * time) y_2d = radius * np.sin(omega * time) # 3D Trajectory (with initial velocity at an angle to the z-axis) vz = v0 * np.cos(angle) # Z-component of velocity vr = v0 * np.sin(angle) # Radial velocity in the x-y plane z_3d = vz * time # Uniform motion along z-axis x_3d = radius * np.cos(omega * time) y_3d = radius * np.sin(omega * time) # Plotting the 2D Trajectory plt.figure(figsize=(8, 6)) plt.plot(x_2d, y_2d, label=\"2D Trajectory (x-y plane)\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"2D Trajectory of Charged Particle in Magnetic Field\") plt.grid() plt.axis(\"equal\") plt.legend() plt.show() # Plotting the 3D Trajectory fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(x_3d, y_3d, z_3d, label=\"3D Trajectory\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") ax.set_title(\"3D Trajectory of Charged Particle in Magnetic Field\") ax.legend() plt.show()","title":"Example Simulation (Uniform Magnetic Field)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation-of-visualization","text":"- The 3D plot demonstrates the trajectory of a charged particle in a uniform magnetic field. - Circular motion is observed due to the Lorentz force acting perpendicular to the particle's velocity, creating a centripetal force. - The radius of the trajectory (Larmor radius) depends on the particle's mass, charge, velocity, and the magnetic field strength. - Variations in initial conditions or field parameters would alter the shape and size of the trajectory, which can be explored by modifying the simulation parameters.","title":"Explanation of Visualization"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory 1.1 Motivation Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for designing and analyzing efficient systems. Traditional methods involve applying series and parallel resistor rules iteratively, but these approaches become complex for large networks. Graph theory provides a systematic approach by representing circuits as graphs, where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values. By leveraging graph-based methods, we can automate circuit analysis, making it useful for simulation software, optimization problems, and network design. This approach also showcases the deep connection between electrical engineering and mathematical graph theory. 1.2 Problem Statement - Given an electrical circuit modeled as a weighted graph, compute the equivalent resistance between two nodes using graph theory. - The circuit may contain arbitrary resistor configurations, including nested series and parallel connections. 2. Approach 2.1 Graph Representation - Nodes : Represent electrical junctions. - Edges : Represent resistors with weights equal to their resistance values. 2.2 Graph Simplification \\(1.\\) Identify Series Connections : - If two resistors share a common node with no branching, they are in series. - Combine them using : \\[ R_{eq} = R_1 + R_2 \\] \\(2.\\) Identify Parallel Connections : - If two resistors connect the same pair of nodes, they are in parallel. - Combine them using : $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ \\(3.\\) Iterative Reduction : - Apply the above rules iteratively until the circuit reduces to a single equivalent resistance. 3. Algorithm Implementation 3.1 Pseudocode function compute_equivalent_resistance(graph, start, end): while graph has more than two nodes: for each node in graph: if node has exactly two neighbors (series case): merge series resistances if two nodes have multiple edges (parallel case): merge parallel resistances return remaining edge weight between start and end 3.2 Python Implementation import networkx as nx def parallel_resistance(resistances): return 1 / sum(1 / r for r in resistances) def reduce_circuit(graph): changed = True while changed: changed = False for node in list(graph.nodes): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: # Series Case n1, n2 = neighbors r1 = graph[node][n1]['weight'] r2 = graph[node][n2]['weight'] graph.add_edge(n1, n2, weight=r1 + r2) graph.remove_node(node) changed = True break for (u, v) in list(graph.edges): # Parallel Case parallel_edges = [d['weight'] for _, _, d in graph.edges(data=True) if _ == u and v == _] if len(parallel_edges) > 1: graph[u][v]['weight'] = parallel_resistance(parallel_edges) changed = True return graph # Example circuit G = nx.Graph() G.add_edge('A', 'B', weight=4) G.add_edge('B', 'C', weight=6) G.add_edge('C', 'A', weight=3) G.add_edge('B', 'D', weight=2) G.add_edge('C', 'D', weight=1) G = reduce_circuit(G) print(\"Equivalent Resistance between A and D:\", G['A']['D']['weight']) 4. Analysis 4.1 Test Cases \\(1.\\) Simple Series-Parallel Network : - Input : Resistors in a simple combination. - Output : Correct equivalent resistance. \\(2.\\) Nested Combinations : - Input : Complex network with multiple levels of simplification. - Output : Consistent resistance calculation. \\(3.\\) General Graph with Cycles : - Input : Arbitrary circuit. - Output : Correct reduction using iterative merging. 4.2 Efficiency - Series Reduction : \\(O(N)\\) for \\(N\\) nodes. - Parallel Reduction : \\(O(E)\\) for \\(E\\) edges. - Total Complexity : Near \\(O(N + E)\\) in practical cases due to iterative graph simplifications. 4.3 Possible Improvements - Implementing more efficient graph traversal techniques (DFS/BFS) to detect reducible structures quickly. - Optimizing data structures for faster merging operations. 5. Conclusion - Using graph theory, we successfully computed the equivalent resistance of an electrical circuit through iterative graph reductions. - This approach provides a structured, algorithmic way to analyze circuits, making it valuable for simulations and automated circuit analysis tools. - By combining fundamental electrical principles with graph-theoretic techniques, we bridge the gap between physics, engineering, and computer science, demonstrating the power of interdisciplinary problem-solving.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#11-motivation","text":"Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for designing and analyzing efficient systems. Traditional methods involve applying series and parallel resistor rules iteratively, but these approaches become complex for large networks. Graph theory provides a systematic approach by representing circuits as graphs, where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values. By leveraging graph-based methods, we can automate circuit analysis, making it useful for simulation software, optimization problems, and network design. This approach also showcases the deep connection between electrical engineering and mathematical graph theory.","title":"1.1 Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#12-problem-statement","text":"- Given an electrical circuit modeled as a weighted graph, compute the equivalent resistance between two nodes using graph theory. - The circuit may contain arbitrary resistor configurations, including nested series and parallel connections.","title":"1.2 Problem Statement"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-approach","text":"","title":"2. Approach"},{"location":"1%20Physics/5%20Circuits/Problem_1/#21-graph-representation","text":"- Nodes : Represent electrical junctions. - Edges : Represent resistors with weights equal to their resistance values.","title":"2.1 Graph Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#22-graph-simplification","text":"\\(1.\\) Identify Series Connections : - If two resistors share a common node with no branching, they are in series. - Combine them using : \\[ R_{eq} = R_1 + R_2 \\] \\(2.\\) Identify Parallel Connections : - If two resistors connect the same pair of nodes, they are in parallel. - Combine them using : $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ \\(3.\\) Iterative Reduction : - Apply the above rules iteratively until the circuit reduces to a single equivalent resistance.","title":"2.2 Graph Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-algorithm-implementation","text":"","title":"3. Algorithm Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#31-pseudocode","text":"function compute_equivalent_resistance(graph, start, end): while graph has more than two nodes: for each node in graph: if node has exactly two neighbors (series case): merge series resistances if two nodes have multiple edges (parallel case): merge parallel resistances return remaining edge weight between start and end","title":"3.1 Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#32-python-implementation","text":"import networkx as nx def parallel_resistance(resistances): return 1 / sum(1 / r for r in resistances) def reduce_circuit(graph): changed = True while changed: changed = False for node in list(graph.nodes): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: # Series Case n1, n2 = neighbors r1 = graph[node][n1]['weight'] r2 = graph[node][n2]['weight'] graph.add_edge(n1, n2, weight=r1 + r2) graph.remove_node(node) changed = True break for (u, v) in list(graph.edges): # Parallel Case parallel_edges = [d['weight'] for _, _, d in graph.edges(data=True) if _ == u and v == _] if len(parallel_edges) > 1: graph[u][v]['weight'] = parallel_resistance(parallel_edges) changed = True return graph # Example circuit G = nx.Graph() G.add_edge('A', 'B', weight=4) G.add_edge('B', 'C', weight=6) G.add_edge('C', 'A', weight=3) G.add_edge('B', 'D', weight=2) G.add_edge('C', 'D', weight=1) G = reduce_circuit(G) print(\"Equivalent Resistance between A and D:\", G['A']['D']['weight'])","title":"3.2 Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-analysis","text":"","title":"4. Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#41-test-cases","text":"\\(1.\\) Simple Series-Parallel Network : - Input : Resistors in a simple combination. - Output : Correct equivalent resistance. \\(2.\\) Nested Combinations : - Input : Complex network with multiple levels of simplification. - Output : Consistent resistance calculation. \\(3.\\) General Graph with Cycles : - Input : Arbitrary circuit. - Output : Correct reduction using iterative merging.","title":"4.1 Test Cases"},{"location":"1%20Physics/5%20Circuits/Problem_1/#42-efficiency","text":"- Series Reduction : \\(O(N)\\) for \\(N\\) nodes. - Parallel Reduction : \\(O(E)\\) for \\(E\\) edges. - Total Complexity : Near \\(O(N + E)\\) in practical cases due to iterative graph simplifications.","title":"4.2 Efficiency"},{"location":"1%20Physics/5%20Circuits/Problem_1/#43-possible-improvements","text":"- Implementing more efficient graph traversal techniques (DFS/BFS) to detect reducible structures quickly. - Optimizing data structures for faster merging operations.","title":"4.3 Possible Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-conclusion","text":"- Using graph theory, we successfully computed the equivalent resistance of an electrical circuit through iterative graph reductions. - This approach provides a structured, algorithmic way to analyze circuits, making it valuable for simulations and automated circuit analysis tools. - By combining fundamental electrical principles with graph-theoretic techniques, we bridge the gap between physics, engineering, and computer science, demonstrating the power of interdisciplinary problem-solving.","title":"5. Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is a cornerstone of probability and statistics. It states that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. Simulations provide an intuitive and hands-on way to observe this phenomenon in action. Deliverables - A Markdown document and Python scripts or notebooks implementing the simulations for various population distributions. - Plots illustrating the sampling distributions and their progression toward normality. - A discussion on the implications of the results and their connection to theoretical expectations. Task 1. Simulating Sampling Distributions - Select several types of population distributions , such as: - Uniform distribution. - Exponential distribution. - Binomial distribution. - For each distribution, generate a large dataset representing the population. 2. Sampling and Visualization - Randomly sample data from the population and calculate the sample mean for different sample sizes (e.g., 5, 10, 30, 50). - Repeat the process multiple times to create a sampling distribution of the sample mean. - Plot histograms of the sample means for each sample size and observe the convergence to a normal distribution. 3. Parameter Exploration - Investigate how the shape of the original distribution and the sample size influence the rate of convergence to normality. - Highlight the impact of the population\u2019s variance on the spread of the sampling distribution. 4. Practical Applications Reflect on the importance of the CLT in real-world scenarios, such as: - Estimating population parameters. - Quality control in manufacturing. - Predicting outcomes in financial models. Python Implementation import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Function to simulate sampling distribution def simulate_clt(population, sample_size, num_samples): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=sample_size, replace=True) sample_means.append(np.mean(sample)) return sample_means # Parameters np.random.seed(42) population_size = 100000 num_samples = 1000 # Population distributions uniform_population = np.random.uniform(0, 1, population_size) exponential_population = np.random.exponential(1, population_size) # Sampling parameters sample_sizes = [5, 10, 30, 50] # Visualization for population, label in zip([uniform_population, exponential_population], [\"Uniform\", \"Exponential\"]): plt.figure(figsize=(14, 10)) for i, sample_size in enumerate(sample_sizes, 1): sample_means = simulate_clt(population, sample_size, num_samples) plt.subplot(2, 2, i) sns.histplot(sample_means, kde=True, bins=30, color=\"blue\") plt.title(f\"{label} Population - Sample Size {sample_size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.tight_layout() plt.show() Summary This task encourages students to explore the Central Limit Theorem through computational experiments, deepening their understanding of its significance in statistics. The simulations and visualizations provide a clear and interactive way to see the CLT in action and its implications in practical applications.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a cornerstone of probability and statistics. It states that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. Simulations provide an intuitive and hands-on way to observe this phenomenon in action.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables","text":"- A Markdown document and Python scripts or notebooks implementing the simulations for various population distributions. - Plots illustrating the sampling distributions and their progression toward normality. - A discussion on the implications of the results and their connection to theoretical expectations.","title":"Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"- Select several types of population distributions , such as: - Uniform distribution. - Exponential distribution. - Binomial distribution. - For each distribution, generate a large dataset representing the population.","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"- Randomly sample data from the population and calculate the sample mean for different sample sizes (e.g., 5, 10, 30, 50). - Repeat the process multiple times to create a sampling distribution of the sample mean. - Plot histograms of the sample means for each sample size and observe the convergence to a normal distribution.","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"- Investigate how the shape of the original distribution and the sample size influence the rate of convergence to normality. - Highlight the impact of the population\u2019s variance on the spread of the sampling distribution.","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications","text":"Reflect on the importance of the CLT in real-world scenarios, such as: - Estimating population parameters. - Quality control in manufacturing. - Predicting outcomes in financial models.","title":"4. Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Function to simulate sampling distribution def simulate_clt(population, sample_size, num_samples): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=sample_size, replace=True) sample_means.append(np.mean(sample)) return sample_means # Parameters np.random.seed(42) population_size = 100000 num_samples = 1000 # Population distributions uniform_population = np.random.uniform(0, 1, population_size) exponential_population = np.random.exponential(1, population_size) # Sampling parameters sample_sizes = [5, 10, 30, 50] # Visualization for population, label in zip([uniform_population, exponential_population], [\"Uniform\", \"Exponential\"]): plt.figure(figsize=(14, 10)) for i, sample_size in enumerate(sample_sizes, 1): sample_means = simulate_clt(population, sample_size, num_samples) plt.subplot(2, 2, i) sns.histplot(sample_means, kde=True, bins=30, color=\"blue\") plt.title(f\"{label} Population - Sample Size {sample_size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.tight_layout() plt.show()","title":"Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#summary","text":"This task encourages students to explore the Central Limit Theorem through computational experiments, deepening their understanding of its significance in statistics. The simulations and visualizations provide a clear and interactive way to see the CLT in action and its implications in practical applications.","title":"Summary"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating Pi Using Monte Carlo Methods Motivation Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications of Monte Carlo methods is estimating the value of \u03c0 through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \u03c0 in an intuitive and visually engaging way. This problem connects fundamental concepts of probability, geometry, and numerical computation. It also provides a gateway to understanding how randomness can be harnessed to solve complex problems in physics, finance, and computer science. The Monte Carlo approach to \u03c0 estimation highlights the versatility and simplicity of this method while offering practical insights into convergence rates and computational efficiency. Deliverables Markdown Document - Clear explanations of the methods and formulas. - A discussion of theoretical foundations and results. Python Scripts - Code for the circle-based Monte Carlo method. - Code for the Buffon\u2019s Needle method. Graphical Outputs - Plots showing random points for the circle-based method. - Visualizations of needle positions for Buffon\u2019s Needle. Analysis - Tables or graphs showing the convergence of estimated \u03c0 as a function of the number of iterations for both methods. - A comparison of the methods in terms of accuracy and computational efficiency. Part 1: Estimating \u03c0 Using a Circle Theoretical Foundation \\(1.\\) The ratio of points inside a circle to the total number of points in a square can be used to estimate \u03c0. \\(2.\\) For a unit circle \\((radius = 1)\\) , the formula for \u03c0 is derived using the area of the circle \\((\u03c0r\u00b2)\\) and the area of the bounding square \\((4r\u00b2)\\) . \\(3.\\) By randomly generating points within the square, we count the number that falls inside the circle and use the ratio to approximate \u03c0. Simulation Below is the Python implementation of the circle-based Monte Carlo method: import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): points_inside_circle = 0 x_points, y_points = [], [] for _ in range(num_points): x, y = np.random.uniform(-1, 1), np.random.uniform(-1, 1) x_points.append(x) y_points.append(y) if x**2 + y**2 <= 1: points_inside_circle += 1 pi_estimate = 4 * points_inside_circle / num_points return pi_estimate, x_points, y_points # Parameters num_points = 10000 pi_estimate, x_points, y_points = estimate_pi_circle(num_points) # Visualization inside_circle = [x**2 + y**2 <= 1 for x, y in zip(x_points, y_points)] plt.figure(figsize=(8, 8)) plt.scatter(np.array(x_points)[inside_circle], np.array(y_points)[inside_circle], s=1, color='blue', label='Inside Circle') plt.scatter(np.array(x_points)[~np.array(inside_circle)], np.array(y_points)[~np.array(inside_circle)], s=1, color='red', label='Outside Circle') plt.title(f\"Monte Carlo Estimation of \u03c0 ({pi_estimate:.4f})\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.legend() plt.axis('equal') plt.grid() plt.show() Analysis - Observe how the estimate of \u03c0 improves as the number of points increases. - Discuss convergence rates and computational considerations for this method. Part 2: Estimating \u03c0 Using Buffon\u2019s Needle Theoretical Foundation \\(1.\\) Buffon\u2019s Needle problem estimates \u03c0 using the probability of a needle crossing parallel lines on a plane. \\(2.\\) The derived formula is: $$ \\pi = \\frac{2 \\cdot \\text{Needle Length} \\cdot \\text{Num Throws}}{\\text{Num Crosses} \\cdot \\text{Distance Between Lines}} $$ \u200b Simulation Below is the Python implementation of Buffon\u2019s Needle method: import numpy as np import matplotlib.pyplot as plt def estimate_pi_buffon(needle_length, distance_between_lines, num_throws): num_crosses = 0 x_positions, angles = [], [] for _ in range(num_throws): x_center = np.random.uniform(0, distance_between_lines / 2) angle = np.random.uniform(0, np.pi / 2) x_positions.append(x_center) angles.append(angle) if x_center <= (needle_length / 2) * np.sin(angle): num_crosses += 1 pi_estimate = (2 * needle_length * num_throws) / (num_crosses * distance_between_lines) return pi_estimate, x_positions, angles # Parameters needle_length = 1 distance_between_lines = 2 num_throws = 10000 pi_estimate, x_positions, angles = estimate_pi_buffon(needle_length, distance_between_lines, num_throws) # Visualization x_line = np.linspace(0, distance_between_lines, 100) y_lines = np.arange(0, num_throws, 2) plt.figure(figsize=(10, 5)) plt.hist(x_positions, bins=50, color='lightblue', alpha=0.7, label='Needle Positions') plt.title(f\"Buffon's Needle Estimation of \u03c0 ({pi_estimate:.4f})\") plt.xlabel(\"X Position of Needle Center\") plt.ylabel(\"Frequency\") plt.legend() plt.grid() plt.show() Analysis - Investigate how the number of needle drops affects the estimate\u2019s accuracy. - Compare the convergence rate of this method to the circle-based approach.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-methods","text":"","title":"Estimating Pi Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications of Monte Carlo methods is estimating the value of \u03c0 through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \u03c0 in an intuitive and visually engaging way. This problem connects fundamental concepts of probability, geometry, and numerical computation. It also provides a gateway to understanding how randomness can be harnessed to solve complex problems in physics, finance, and computer science. The Monte Carlo approach to \u03c0 estimation highlights the versatility and simplicity of this method while offering practical insights into convergence rates and computational efficiency.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deliverables","text":"","title":"Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_2/#markdown-document","text":"- Clear explanations of the methods and formulas. - A discussion of theoretical foundations and results.","title":"Markdown Document"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-scripts","text":"- Code for the circle-based Monte Carlo method. - Code for the Buffon\u2019s Needle method.","title":"Python Scripts"},{"location":"1%20Physics/6%20Statistics/Problem_2/#graphical-outputs","text":"- Plots showing random points for the circle-based method. - Visualizations of needle positions for Buffon\u2019s Needle.","title":"Graphical Outputs"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis","text":"- Tables or graphs showing the convergence of estimated \u03c0 as a function of the number of iterations for both methods. - A comparison of the methods in terms of accuracy and computational efficiency.","title":"Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"\\(1.\\) The ratio of points inside a circle to the total number of points in a square can be used to estimate \u03c0. \\(2.\\) For a unit circle \\((radius = 1)\\) , the formula for \u03c0 is derived using the area of the circle \\((\u03c0r\u00b2)\\) and the area of the bounding square \\((4r\u00b2)\\) . \\(3.\\) By randomly generating points within the square, we count the number that falls inside the circle and use the ratio to approximate \u03c0.","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation","text":"Below is the Python implementation of the circle-based Monte Carlo method: import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): points_inside_circle = 0 x_points, y_points = [], [] for _ in range(num_points): x, y = np.random.uniform(-1, 1), np.random.uniform(-1, 1) x_points.append(x) y_points.append(y) if x**2 + y**2 <= 1: points_inside_circle += 1 pi_estimate = 4 * points_inside_circle / num_points return pi_estimate, x_points, y_points # Parameters num_points = 10000 pi_estimate, x_points, y_points = estimate_pi_circle(num_points) # Visualization inside_circle = [x**2 + y**2 <= 1 for x, y in zip(x_points, y_points)] plt.figure(figsize=(8, 8)) plt.scatter(np.array(x_points)[inside_circle], np.array(y_points)[inside_circle], s=1, color='blue', label='Inside Circle') plt.scatter(np.array(x_points)[~np.array(inside_circle)], np.array(y_points)[~np.array(inside_circle)], s=1, color='red', label='Outside Circle') plt.title(f\"Monte Carlo Estimation of \u03c0 ({pi_estimate:.4f})\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.legend() plt.axis('equal') plt.grid() plt.show()","title":"Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis_1","text":"- Observe how the estimate of \u03c0 improves as the number of points increases. - Discuss convergence rates and computational considerations for this method.","title":"Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"\\(1.\\) Buffon\u2019s Needle problem estimates \u03c0 using the probability of a needle crossing parallel lines on a plane. \\(2.\\) The derived formula is: $$ \\pi = \\frac{2 \\cdot \\text{Needle Length} \\cdot \\text{Num Throws}}{\\text{Num Crosses} \\cdot \\text{Distance Between Lines}} $$ \u200b","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation_1","text":"Below is the Python implementation of Buffon\u2019s Needle method: import numpy as np import matplotlib.pyplot as plt def estimate_pi_buffon(needle_length, distance_between_lines, num_throws): num_crosses = 0 x_positions, angles = [], [] for _ in range(num_throws): x_center = np.random.uniform(0, distance_between_lines / 2) angle = np.random.uniform(0, np.pi / 2) x_positions.append(x_center) angles.append(angle) if x_center <= (needle_length / 2) * np.sin(angle): num_crosses += 1 pi_estimate = (2 * needle_length * num_throws) / (num_crosses * distance_between_lines) return pi_estimate, x_positions, angles # Parameters needle_length = 1 distance_between_lines = 2 num_throws = 10000 pi_estimate, x_positions, angles = estimate_pi_buffon(needle_length, distance_between_lines, num_throws) # Visualization x_line = np.linspace(0, distance_between_lines, 100) y_lines = np.arange(0, num_throws, 2) plt.figure(figsize=(10, 5)) plt.hist(x_positions, bins=50, color='lightblue', alpha=0.7, label='Needle Positions') plt.title(f\"Buffon's Needle Estimation of \u03c0 ({pi_estimate:.4f})\") plt.xlabel(\"X Position of Needle Center\") plt.ylabel(\"Frequency\") plt.legend() plt.grid() plt.show()","title":"Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis_2","text":"- Investigate how the number of needle drops affects the estimate\u2019s accuracy. - Compare the convergence rate of this method to the circle-based approach.","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration \\(g\\) due to gravity is a fundamental physical constant that governs the motion of objects in a gravitational field. This experiment explores how a simple pendulum can be used to determine \\(g\\) accurately, emphasizing the importance of precise measurements and uncertainty analysis in experimental physics. Procedure Materials A string (1 or 1.5 meters long) A small weight (e.g., bag of coins, bag of sugar, key chain) Stopwatch or smartphone timer Ruler or measuring tape Setup \\(1\\) . Attach the weight to the string and secure the other end to a sturdy support. \\(2\\) . Measure the length of the pendulum, \\(L\\) , from the suspension point to the center of the weight using a ruler or measuring tape. - Record the resolution of the measuring tool (e.g., 1 mm). - Calculate the uncertainty in \\(L\\) as half the resolution: $$ \\Delta L = \\frac{\\text{Resolution}} {2}$$ Data Collection Displace the pendulum slightly ( \\(<15^\\circ\\) ) and release it. Measure the time for 10 full oscillations ( \\(T_{10}\\) ) using a stopwatch. Record the time to the nearest resolution of the stopwatch. Repeat the measurement 10 times to obtain 10 values of \\(T_{10}\\) . Calculate: The mean time for 10 oscillations: \\(\\overline{T}_{10} = \\frac{\\sum T_{10}}{10}\\) . The standard deviation: \\(\\sigma_{T_{10}} = \\sqrt{\\frac{\\sum (T_{10} - \\overline{T}_{10})^2}{n - 1}}\\) , where \\(n = 10\\) . The uncertainty in the mean: \\(\\Delta \\overline{T}_{10} = \\frac{\\sigma_{T_{10}}}{\\sqrt{n}}\\) . Calculations 1. Calculate the Period The period of one oscillation is: \\[ T = \\frac{\\overline{T}_{10}}{10} \\] The uncertainty in \\(T\\) is: \\[ \\Delta T = \\frac{\\Delta \\overline{T}_{10}}{10} \\] 2. Determine \\(g\\) Using the formula for the period of a pendulum: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] Rearranging for \\(g\\) : \\[ g = \\frac{4\\pi^2 L}{T^2} \\] The uncertainty in \\(g\\) is propagated as: \\[ \\Delta g = g \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2\\frac{\\Delta T}{T}\\right)^2} \\] Simulation Below is the Python implementation of Buffon\u2019s Needle method: import numpy as np import matplotlib.pyplot as plt # Function to calculate uncertainties def calculate_uncertainties(L, delta_L, times): n = len(times) mean_time_10 = np.mean(times) std_dev_time_10 = np.std(times, ddof=1) delta_mean_time_10 = std_dev_time_10 / np.sqrt(n) T = mean_time_10 / 10 delta_T = delta_mean_time_10 / 10 g = (4 * np.pi**2 * L) / T**2 delta_g = g * np.sqrt((delta_L / L)**2 + (2 * delta_T / T)**2) return T, delta_T, g, delta_g # Data collection (Example Values) L = 1.0 # Pendulum length in meters delta_L = 0.001 # Uncertainty in length in meters times = [15.62, 15.59, 15.65, 15.60, 15.64, 15.58, 15.61, 15.63, 15.60, 15.62] # Time for 10 oscillations in seconds # Perform calculations T, delta_T, g, delta_g = calculate_uncertainties(L, delta_L, times) # Display results print(\"Mean Period for 1 Oscillation (T): {:.4f} s \u00b1 {:.4f} s\".format(T, delta_T)) print(\"Gravitational Acceleration (g): {:.4f} m/s^2 \u00b1 {:.4f} m/s^2\".format(g, delta_g)) # Visualization plt.figure(figsize=(10, 6)) plt.plot(range(1, len(times) + 1), times, marker='o', linestyle='-', color='skyblue', label='Oscillation Times') plt.axhline(np.mean(times), color='red', linestyle='dashed', linewidth=1, label=f\"Mean Time: {np.mean(times):.2f} s\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Time for 10 Oscillations (s)\") plt.title(\"Oscillation Times Across Trials\") plt.legend() plt.grid() plt.show() Analysis 1. Compare Measured \\(g\\) with the Standard Value Compare your experimental value of \\(g\\) with the standard value \\(g_{\\text{standard}} = 9.81 \\, \\text{m/s}^2\\) . 2. Discussion Effect of Measurement Resolution on \\(g\\) : Explore how the precision of \\(L\\) and \\(T_{10}\\) affects the final uncertainty in \\(g\\) . Variability in Timing: Discuss the variability in \\(T_{10}\\) measurements and its impact on the mean period and uncertainty. Assumptions and Limitations: Assume air resistance and friction at the pivot are negligible. Small-angle approximation ( \\(<15^\\circ\\) ) is used to ensure the formula for \\(g\\) is valid. Deliverables Tabulated Data Trial \\(T_{10} \\, (\\text{s})\\) Deviation from Mean ( \\(T_{10} - \\overline{T}_{10}\\) ) 1 ... ... 2 ... ... ... ... ... 10 ... ... Mean \\(\\overline{T}_{10}\\) : ... ... Standard Deviation \\(\\sigma_{T_{10}}\\) : ... ... Calculations and Results Mean period: \\(\\overline{T}_{10}\\) Period of one oscillation: \\(T \\pm \\Delta T\\) Measured \\(g \\pm \\Delta g\\) Discussion Provide insights into the sources of uncertainty, their propagation, and their influence on the accuracy of \\(g\\) . Highlight potential improvements for future experiments.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration \\(g\\) due to gravity is a fundamental physical constant that governs the motion of objects in a gravitational field. This experiment explores how a simple pendulum can be used to determine \\(g\\) accurately, emphasizing the importance of precise measurements and uncertainty analysis in experimental physics.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"A string (1 or 1.5 meters long) A small weight (e.g., bag of coins, bag of sugar, key chain) Stopwatch or smartphone timer Ruler or measuring tape","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#setup","text":"\\(1\\) . Attach the weight to the string and secure the other end to a sturdy support. \\(2\\) . Measure the length of the pendulum, \\(L\\) , from the suspension point to the center of the weight using a ruler or measuring tape. - Record the resolution of the measuring tool (e.g., 1 mm). - Calculate the uncertainty in \\(L\\) as half the resolution: $$ \\Delta L = \\frac{\\text{Resolution}} {2}$$","title":"Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"Displace the pendulum slightly ( \\(<15^\\circ\\) ) and release it. Measure the time for 10 full oscillations ( \\(T_{10}\\) ) using a stopwatch. Record the time to the nearest resolution of the stopwatch. Repeat the measurement 10 times to obtain 10 values of \\(T_{10}\\) . Calculate: The mean time for 10 oscillations: \\(\\overline{T}_{10} = \\frac{\\sum T_{10}}{10}\\) . The standard deviation: \\(\\sigma_{T_{10}} = \\sqrt{\\frac{\\sum (T_{10} - \\overline{T}_{10})^2}{n - 1}}\\) , where \\(n = 10\\) . The uncertainty in the mean: \\(\\Delta \\overline{T}_{10} = \\frac{\\sigma_{T_{10}}}{\\sqrt{n}}\\) .","title":"Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period","text":"The period of one oscillation is: \\[ T = \\frac{\\overline{T}_{10}}{10} \\] The uncertainty in \\(T\\) is: \\[ \\Delta T = \\frac{\\Delta \\overline{T}_{10}}{10} \\]","title":"1. Calculate the Period"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-determine-g","text":"Using the formula for the period of a pendulum: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] Rearranging for \\(g\\) : \\[ g = \\frac{4\\pi^2 L}{T^2} \\] The uncertainty in \\(g\\) is propagated as: \\[ \\Delta g = g \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2\\frac{\\Delta T}{T}\\right)^2} \\]","title":"2. Determine \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#simulation","text":"Below is the Python implementation of Buffon\u2019s Needle method: import numpy as np import matplotlib.pyplot as plt # Function to calculate uncertainties def calculate_uncertainties(L, delta_L, times): n = len(times) mean_time_10 = np.mean(times) std_dev_time_10 = np.std(times, ddof=1) delta_mean_time_10 = std_dev_time_10 / np.sqrt(n) T = mean_time_10 / 10 delta_T = delta_mean_time_10 / 10 g = (4 * np.pi**2 * L) / T**2 delta_g = g * np.sqrt((delta_L / L)**2 + (2 * delta_T / T)**2) return T, delta_T, g, delta_g # Data collection (Example Values) L = 1.0 # Pendulum length in meters delta_L = 0.001 # Uncertainty in length in meters times = [15.62, 15.59, 15.65, 15.60, 15.64, 15.58, 15.61, 15.63, 15.60, 15.62] # Time for 10 oscillations in seconds # Perform calculations T, delta_T, g, delta_g = calculate_uncertainties(L, delta_L, times) # Display results print(\"Mean Period for 1 Oscillation (T): {:.4f} s \u00b1 {:.4f} s\".format(T, delta_T)) print(\"Gravitational Acceleration (g): {:.4f} m/s^2 \u00b1 {:.4f} m/s^2\".format(g, delta_g)) # Visualization plt.figure(figsize=(10, 6)) plt.plot(range(1, len(times) + 1), times, marker='o', linestyle='-', color='skyblue', label='Oscillation Times') plt.axhline(np.mean(times), color='red', linestyle='dashed', linewidth=1, label=f\"Mean Time: {np.mean(times):.2f} s\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Time for 10 Oscillations (s)\") plt.title(\"Oscillation Times Across Trials\") plt.legend() plt.grid() plt.show()","title":"Simulation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-compare-measured-g-with-the-standard-value","text":"Compare your experimental value of \\(g\\) with the standard value \\(g_{\\text{standard}} = 9.81 \\, \\text{m/s}^2\\) .","title":"1. Compare Measured \\(g\\) with the Standard Value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-discussion","text":"Effect of Measurement Resolution on \\(g\\) : Explore how the precision of \\(L\\) and \\(T_{10}\\) affects the final uncertainty in \\(g\\) . Variability in Timing: Discuss the variability in \\(T_{10}\\) measurements and its impact on the mean period and uncertainty. Assumptions and Limitations: Assume air resistance and friction at the pivot are negligible. Small-angle approximation ( \\(<15^\\circ\\) ) is used to ensure the formula for \\(g\\) is valid.","title":"2. Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables","text":"","title":"Deliverables"},{"location":"1%20Physics/7%20Measurements/Problem_1/#tabulated-data","text":"Trial \\(T_{10} \\, (\\text{s})\\) Deviation from Mean ( \\(T_{10} - \\overline{T}_{10}\\) ) 1 ... ... 2 ... ... ... ... ... 10 ... ... Mean \\(\\overline{T}_{10}\\) : ... ... Standard Deviation \\(\\sigma_{T_{10}}\\) : ... ...","title":"Tabulated Data"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations-and-results","text":"Mean period: \\(\\overline{T}_{10}\\) Period of one oscillation: \\(T \\pm \\Delta T\\) Measured \\(g \\pm \\Delta g\\)","title":"Calculations and Results"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"Provide insights into the sources of uncertainty, their propagation, and their influence on the accuracy of \\(g\\) . Highlight potential improvements for future experiments.","title":"Discussion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}